
import React from 'react';
import Card from '../../components/ui/Card';

const Section: React.FC<{ title: string; children: React.ReactNode }> = ({ title, children }) => (
    <section className="mb-8">
        <h2 className="text-2xl font-semibold text-text-primary border-b border-border pb-2 mb-4">{title}</h2>
        <div className="text-text-secondary space-y-4">{children}</div>
    </section>
);

const HuffmanCodingArticle: React.FC = () => {
  return (
    <div className="prose prose-invert max-w-none">
      <Card className="bg-background-secondary">
        <div className="p-4">
            <Section title="Definition & Real-World Applications">
                <p>Huffman Coding is a greedy algorithm used for lossless data compression. It assigns variable-length codes to input characters, with the lengths of the assigned codes based on the frequencies of corresponding characters. The most frequent character gets the smallest code and the least frequent character gets the largest code.</p>
                <p>It is widely used in compression formats like GZIP, PKZIP (winzip, etc.), and BZIP2, as well as image formats like JPEG and PNG.</p>
            </Section>

            <Section title="Step-by-Step Walkthrough">
                <ol className="list-decimal list-inside space-y-2">
                    <li><strong>Calculate Frequencies:</strong> Scan the input text and create a frequency count for each unique character.</li>
                    <li><strong>Create Leaf Nodes:</strong> Create a leaf node for each unique character, containing the character and its frequency. Add these nodes to a priority queue (min-heap), where the node with the lowest frequency has the highest priority.</li>
                    <li><strong>Build the Tree:</strong>
                        <ul className="list-disc list-inside ml-4">
                            <li>Extract the two nodes with the minimum frequency from the priority queue.</li>
                            <li>Create a new internal node. Its frequency is the sum of the two extracted nodes' frequencies. Make the first extracted node its left child and the second its right child.</li>
                            <li>Add this new internal node back into the priority queue.</li>
                        </ul>
                    </li>
                    <li><strong>Repeat:</strong> Continue step 3 until only one node remains in the queue. This single node is the root of the Huffman Tree.</li>
                    <li><strong>Assign Codes:</strong> Traverse the Huffman Tree from the root to each leaf node. Assign '0' for a left turn and '1' for a right turn. The sequence of 0s and 1s on the path from the root to a leaf forms the Huffman code for the character in that leaf.</li>
                </ol>
            </Section>

            <Section title="Key Properties">
                <p>The codes generated by Huffman's algorithm are <strong>prefix codes</strong>. This means that the code assigned to any character is not a prefix of the code assigned to any other character. This property is crucial as it ensures that there is no ambiguity when decoding the compressed bitstream.</p>
            </Section>
            
            <Section title="Practice Problems">
                <div className="space-y-3">
                    <p><strong>1.</strong> Generate the Huffman codes for the following string: "this is an example of a huffman tree".</p>
                    <p><strong>2.</strong> Why is a priority queue (min-heap) an efficient data structure for building the Huffman tree?</p>
                    <p><strong>3.</strong> If a text consisted of only one repeated character (e.g., "AAAAA"), what would its Huffman code be?</p>
                </div>
            </Section>
        </div>
      </Card>
    </div>
  );
};

export default HuffmanCodingArticle;
